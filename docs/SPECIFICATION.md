# Спецификация формата взаимодействия

Данный документ стандартизирует взаимодействие между клиентами и сервером SynXpo.

## Оглавление
- [Общая информация](#общая-информация)
- [Подписка на директории](#подписка-на-директории)
  - [Создание директории](#создание-директории)
  - [Подписка на директорию](#подписка-на-директорию)
  - [Отписка от директории](#отписка-от-директории)
- [Отправка новой версии](#отправка-новой-версии)
  - [Клиент](#клиент)
  - [Сервер](#сервер)
- [Обновление данных](#обновление-данных)
  - [Клиент](#клиент-1)
  - [Сервер](#сервер-1)
- [Диаграммы взаимодействия](#диаграммы-взаимодействия)

## Общая информация
- Клиент и сервер общаются по протоколу gRPC.
- Каждый файл ассоциируется с версией — целым беззнаковым 64-битным числом. Версии нумеруются с 1.
- Временная метка представляется Unix timestamp в микросекундах (`TIMESTAMP`).
- Сервер хранит для каждого файла структуру `LAST_TRY = (time, connection_id)`, где `time` — временная метка последнего запроса `ASK_VERSION_INCREASE`, `connection_id` — внутренний идентификатор gRPC-соединения, от которого пришел запрос. Для новых файлов `LAST_TRY` инициализируется значением `(0, null)`.
- Событие `CHECK_VERSION` содержит список файлов и их текущие версии на сервере.

## Подписка на директории
### Создание директории
1. Для создания новой директории, файлы в которой будут синхронизироваться, клиент отправляет серверу запрос `DIRECTORY_CREATE`, на что сервер отвечает сообщением `OK_DIRECTORY_CREATED` с полем `DIRECTORY_ID`.
2. Клиент сам связывает полученный id с некоторой локальной директорией. Сервер не знает местоположение этой директории, только её содержимое.
3. После получения `OK_DIRECTORY_CREATED` клиент инициирует отправку новой версии по обычным правилам.

### Подписка на директорию
1. Для подписки на уже существующую директорию клиент отправляет серверу запрос `DIRECTORY_SUBSCRIBE`, содержащий id директории, на что сервер отвечает сообщением `OK_SUBSCRIBED`.
2. После этого сервер ОБЯЗАН отправлять события `CHECK_VERSION` при изменении файлов в этой директории.
3. Клиент ОБЯЗАН подписываться на релевантные директории при каждом запуске, так как подписки связаны с gRPC-соединением и удаляются при его разрыве.
4. После подписки на директорию клиент инициирует обновление данных по обычным правилам.

### Отписка от директории
1. Для отписки от директории клиент отправляет серверу запрос `DIRECTORY_UNSUBSCRIBE`, содержащий id директории, на что сервер отвечает сообщением `OK_UNSUBSCRIBED`.
2. После этого сервер не отправляет события `CHECK_VERSION` при изменении файлов в этой директории.
3. Если клиент всё же продолжает получать такие события, он обязан их игнорировать.

## Отправка новой версии

### Клиент
1. Клиент периодически проверяет, не изменились ли файлы, за которыми установлено отслеживание.
2. Если произошло изменение, клиент немедленно сохраняет локальную измененную копию файла в безопасное место.
3. Если произошло изменение, клиент устанавливает параметр `FIRST_TRY_TIME: TIMESTAMP` для этого файла, используя текущее время. При дальнейшей отправке запросов этот параметр не должен изменяться, если только файл не был снова модифицирован.
4. Если произошло изменение, клиент отправляет на сервер запрос `ASK_VERSION_INCREASE` с указанием списка файлов, которые изменились.
5. Сервер проверяет, не записывает ли какой-то другой клиент сейчас изменения в один из файлов (поток заблокирован). 
6. Если хотя бы один файл заблокирован, сервер возвращает ответ `VERSION_INCREASE_DENY` с указанием списка заблокированных файлов. Для каждого файла указан статус: `FREE`, `BLOCKED`, `DENIED`. Клиент ОБЯЗАН:
    1. Для незаблокированных файлов (`FREE`) немедленно повторить запрос `ASK_VERSION_INCREASE` и следовать этому алгоритму.
    2. Запомнить заблокированные файлы (`BLOCKED`) и повторить запрос `ASK_VERSION_INCREASE` при получении события `CHECK_VERSION`, затрагивающего заблокированные файлы, после чего следовать этому алгоритму.
    3. Для файлов `DENIED` инициировать процесс обновления данных после завершения алгоритма отправки новой версии.
7. Если никакой файл не заблокирован, сервер возвращает ответ `VERSION_INCREASE_ALLOW`. Клиент ОБЯЗАН немедленно начать отправку потока сообщений `FILE_WRITE` с содержимым обновляемых файлов, после чего закончить отправку сообщением `FILE_WRITE_END` и увеличить локальные версии обновлённых файлов на 1.
8. Клиент ДОЛЖЕН разбивать файлы на фрагменты размером не более 1 MB и отправлять их последовательными сообщениями `FILE_WRITE`, чтобы гарантировать интервал между сообщениями менее 30 секунд даже при медленном соединении.
9. В случае если между отправками `FILE_WRITE` пройдёт более 30 секунд, сервер снимет блокировку со всех файлов и откатит изменения, после чего следующие запросы `FILE_WRITE` упадут с ошибкой. При получении ошибки клиент ОБЯЗАН начать алгоритм заново.
10. После завершения алгоритма клиент возобновляет отслеживание файлов. Во время выполнения данного алгоритма отслеживание не должно выполняться во избежание конфликтов (исключение: пункт 6.2).

### Сервер
1. При получении запроса `ASK_VERSION_INCREASE` для каждого отправленного файла сервер проверяет структуру `LAST_TRY = (time, connection_id)`, которую он хранит у себя.
    1. Если `LAST_TRY.time > FIRST_TRY_TIME`, сервер немедленно помечает файл как `DENIED`.
    2. Если `LAST_TRY.time < FIRST_TRY_TIME` ИЛИ если `LAST_TRY.time == FIRST_TRY_TIME` И `LAST_TRY.connection_id` совпадает с текущим соединением (повторный запрос того же клиента), сервер устанавливает `LAST_TRY = (FIRST_TRY_TIME, connection_id)` и:
        1. Если в файл сейчас кто-то пишет или из него кто-то читает, помечает его как `BLOCKED`.
        2. Иначе помечает его как `FREE`.
    3. Иначе сервер помечает файл как `DENIED`.
2. Если хотя бы один файл не помечен как `FREE`, сервер отправляет ответ `VERSION_INCREASE_DENY` и завершает обработку.
3. Иначе сервер помечает, что в запрошенные файлы идёт запись, сохраняет свои версии файлов в безопасное место и отправляет ответ `VERSION_INCREASE_ALLOW`.
4. После отправки `VERSION_INCREASE_ALLOW` сервер ожидает первое сообщение `FILE_WRITE` в течение 10 секунд. Если сообщение не получено, блокировка освобождается.
5. Сервер принимает все файлы и записывает их к себе в хранилище.
6. Для каждого изменённого файла сервер увеличивает его версию на 1.
7. Сервер отслеживает время последнего полученного сообщения `FILE_WRITE` от клиента. Если сервер не получает очередное сообщение `FILE_WRITE` или завершающее сообщение `FILE_WRITE_END` в течение 30 секунд с момента предыдущего сообщения, он:
    1. Откатывает все частично записанные изменения для данного клиента.
    2. Освобождает блокировки на соответствующие файлы.
    3. Не увеличивает версии файлов.
8. После получения сообщения `FILE_WRITE_END` сервер отправляет событие `CHECK_VERSION` всем клиентам, подписанным на изменённые файлы, кроме клиента который производил запись.

## Обновление данных

### Клиент
Клиент инициирует обновление данных у себя:
1. При запуске, отправляя команду `REQUEST_VERSION` со списком id отслеживаемых директорий. На эту команду сервер отвечает отправкой события `CHECK_VERSION`.
2. При получении события `CHECK_VERSION`.
3. При получении ответа `DENIED` на запрос `ASK_VERSION_INCREASE`, отправляя команду `REQUEST_VERSION` со списком файлов, которые были помечены как `DENIED`.

Процесс обновления данных происходит следующим образом:
1. Клиент сравнивает версии файлов, полученные от сервера, с локальными версиями.
2. Клиент запрашивает содержимое файлов, у которых версия на сервере превышает версию на клиенте. Для этого он сохраняет текущие локальные версии в безопасное место и отправляет запрос `REQUEST_FILE_CONTENT` с необходимым списком файлов.
3. Если в какой-то из запрошенных файлов сейчас идёт запись, сервер возвращает ответ `FILE_CONTENT_REQUEST_DENY`. Для каждого файла указан статус: `FREE`, `BLOCKED`. Клиент ОБЯЗАН:
    1. Для незаблокированных файлов (`FREE`) немедленно повторить запрос `REQUEST_FILE_CONTENT` и следовать этому алгоритму.
    2. Не делать ничего для заблокированных файлов, так как при окончании записи он снова получит событие `CHECK_VERSION`.
4. Если никакой файл не заблокирован, сервер возвращает ответ `FILE_CONTENT_REQUEST_ALLOW`, после чего поток событий `FILE_WRITE`, оканчивающийся событием `FILE_WRITE_END`. Клиент записывает данные в релевантные файлы. Во избежание конфликтов, перед началом записи клиент должен заблокировать релевантные файлы для записи другими программами средствами операционной системы.
5. В случае если между получением сообщений `FILE_WRITE` от сервера пройдёт более 30 секунд, клиент восстанавливает файлы из сохранённых резервных копий, снимает блокировки и повторяет запрос `REQUEST_FILE_CONTENT` заново. При этом он игнорирует все последующие события `FILE_WRITE` до тех пор, пока не получит `FILE_WRITE_END`.
6. После получения всех данных клиент обрабатывает файлы, у которых отсутствует версия, запуская для них процесс отправки новой версии, как описано выше. 
7. Для файлов, у которых текущая версия превышает версию на сервере, клиент ничего не делает, так как они уже были обновлены на сервере.

Во время получения данных клиент не должен прерываться на проверку наличия локальных изменений во избежание конфликтов.

### Сервер
1. При получении запроса `REQUEST_FILE_CONTENT` для каждого запрошенного файла сервер проверяет, не ведётся ли в него запись, и помечает файлы `BLOCKED` или `FREE` соответственно.
2. Если хотя бы один файл не помечен как `FREE`, сервер отправляет ответ `FILE_CONTENT_REQUEST_DENY` и завершает обработку.
3. Иначе сервер блокирует релевантные файлы для записи другими клиентами, отправляет ответ `FILE_CONTENT_REQUEST_ALLOW`, после чего отправляет сообщения `FILE_WRITE` с содержимым файлов, а затем событие `FILE_WRITE_END` и разблокирует файлы.
4. Сервер ДОЛЖЕН разбивать файлы на фрагменты размером не более 1 MB и отправлять их последовательными сообщениями `FILE_WRITE`, чтобы гарантировать интервал между сообщениями менее 30 секунд даже при медленном соединении.

## Диаграммы взаимодействия

### Отправка новой версии файла
![Отправка файла](resources/png/file-upload.png)

### Получение обновленных файлов
![Скачивание файла](resources/png/file-download.png)

### Конфликт: файл заблокирован другим клиентом
![Конфликт BLOCKED](resources/png/conflict-blocked.png)

### Конфликт: устаревший запрос (DENIED)
![Конфликт DENIED](resources/png/conflict-denied.png)

### Таймаут при загрузке файла
![Таймаут](resources/png/timeout-upload.png)

### Подписка на директории
![Подписка](resources/png/subscription.png)

### Частичный отказ: FREE и BLOCKED/DENIED
![Частичный отказ](resources/png/partial-deny.png)